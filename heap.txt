                                                                                         Процессы и потоки
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
"ПРОЦЕСС" - это выделенная область внутри оперативной памяти куда загружаются исполняемые программные данные

"ПОТОК" - это выделенное процессорное время в период которого происходит обработка и выполнение программных инструкций, которые лежат внутри процесса (внутри "1-процесса" "потоков"
          может быть несколько...)

По своей природе "процессы" и "ПОТОКИ" реализованы на уровне Операционной Системы, механизмы их реализации для каждой Операционной Системы разные...

Чтобы управлять такими "потоками" в Java есть класс "Thread". Механизм управление состоит из 2-этапов:
1. Создание объекта внутри VM-Java, который будет управлять потоком через Операционную Систему
2. И запуск этого "потока" внутри Операционной Системы (средствами Операционной Системы)

Сам же "поток" представляет участок кода (то есть, "поток" - это тоже программа)... Чтобы неплодить объекты которые расширяют класс "Thread" в Java есть интерфейс "Runnable"
(команда) - в котором лежит участок кода

                                                                                    Критические ресурсы и секции
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Основная сложность при разработке многопоточных приложений - это использование общих ресурсов (каждым потоком), это и есть так называемые: "КРИТИЧЕСКИЕ РЕСУРСЫ" и "КРИТИЧЕСКИЕ
СЕКЦИИ"

"МОНИТОР" (синхронизация) — (в языках программирования) высокоуровневый механизм синхронизации процессов, который обеспечивающий доступ к неразделяемым ресурсам
                            Работу synchronized-методов и synchronized-блоков обеспечивает "монитор"

Эти методы предназначены для межпоточной синхронизации, для взаимодействия "потоков" между собой и могут вызваны только "потоком", который захватил "монитор" объекта:
"synchronized(...)" ... является критической секцией — это значит, что в любой момент времени только 1-поток может находится внутри критической секции в активном состоянии
"wait()" .............. переводит "поток", её вызвавший в заблокированное состояние (приостанавливает выполнение "потока" - "поток" уходит в сон)
"notify()" ............ переводит-пробуждает один из ждущих "потоков" из блокированного состояния в активное. Однако пробуждённый поток не может выполнятся пока "будильник" не
                        освободит блокировку объекта
"notifyAll()" ......... аналогична notify(), только она пробуждает не один, а все потоки ожидающие данный объект
Методы "wait()", "notify()" и "notifyAll()" должны обязательно находиться внутри блока "synchronized", либо внутри "synchronized-метода" (иначе вы получите Exception).
Как только "поток-1" достигает метода "wait()" он перестает быть владельцем "монитора" и блокировка для блока синхронизации снимается, а сам "поток" уходит в сон. Тогда же
"поток-2" сможет попасть в блок синхронизации, чтобы вызвать "notifyAll()" (неважно кто вызовет "notify()" у объекта на котором висит "поток-1", главное чтобы кто-то захватил
"монитор" и освободил его методом "notify()" или "notifyAll()")
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
1. Сам "Поток" заблокироваться НЕможет.
2. Можно захватить/освободить "монитор" только над объектом (монитор объекта - это и будет "критический ресурс").
3. По существу - "монитор объекта" может быть захвачен/освобожден только внутри любого синхронизированного блока-метода.
4. "Поток" может захватыватить "монитор объекта" и блокирует (его) эту критическую секцию (становится владельцем объекта "monitor" и блокирует).
   А метод "wait()" переводит "поток", его вызвавший, в сон (приостанавливает выполнение "потока" - состояние ожидания до тех пор пока другой "поток" его будит).
   Как только приостанавливается выполнение "потока" - тогда ("поток" отпускает "монитор") освобождается "монитор" и разблокируется эту критическую секцию (блок "synchronized(...)").

(Жизненный цикл потока) http://www.bsu.by/Cache/pdf/87943.pdf
 ---------------------
При выполнении программы объект класса Thread может быть в одном из четырех основных состояний: “новый”, “работоспособный”, “неработоспособный” и “пассивный”. При создании потока он
получает состояние “новый” (NEW) и не выполняется. Для перевода потока из состояния “новый” в состояние “работоспособный” (RUNNABLE) следует выполнить метод start(), который вызывает
метод run()–основной метод потока.
Поток может находиться в одном из состояний, соответствующих элементам статически вложенного перечисления Thread.State:
"NEW" ............. поток создан, но еще не запущен;
"RUNNABLE" ........ поток выполняется;
"BLOCKED" ......... поток блокирован;
"WAITING" ......... поток ждет окончания работы другого потока;
"TIMED_WAITING" ... поток некоторое время ждет окончания другого потока;
"TERMINATED" ...... поток завершен;
Получить значение состояния потока можно вызовом метода getState().
Поток переходит в состояние “неработоспособный” (WAITING) вызовом методов wait(), suspend()(deprecated-метод) или методов ввода/вывода, которые предполагают задержку. Для задержки
потока на некоторое время (в миллисекундах) можно перевести его в режим ожидания (TIMED_WAITING) с помощью методов sleep(long millis) и wait(long timeout), при выполнении которого
может генерироваться прерывание InterruptedException. Вернуть потоку работоспособность после вызова метода suspend() можно методом resume()(deprecated-метод), а после вызова метода
wait() – методами notify() или notifyAll(). Поток переходит в “пассивное” состояние (TERMINATED), если вызваны методы interrupt(), stop() (deprecated-метод) или метод run() завершил
выполнение. После этого, чтобы запустить поток еще раз, необходимо создать новый объект потока. Метод interrupt() успешно завершает поток, если он находится в состоянии
“работоспособность”. Если же поток неработоспособен, то метод генерирует исключительные ситуации разного типа в зависимости от способа остановки потока.
Интерфейс Runnable не имеет метода start(), а только единственный метод run(). Поэтому для запуска такого потока, как Walk, следует создать объект класса Thread и передать объект
Walk его конструктору. Однако при прямомвызове метода run() поток не запустится, выполнится только тело самого метода.
Методы suspend(), resume() и stop() являются deprecated-методами и запрещены к использованию, так как они не являются в полной мере “потоко-безопасными”.


(О поддержке параллелизма в Java * synchronized) http://programmersnook.blogspot.com/2012/05/java.html
-----------------------------------------------
  Самый простой способ использования блокировок в Java - это так называемые мониторы или внутренние блокировки (monitor, intrinsic lock). Существует два варианта
синтаксических форм обеспечения синхронизации выполняемого участка кода. В каждом из них используется ключевое слово synchronized. В первом, ключевое слово используется в
качестве модификатора в объявлении метода, во втором в выделении блока кода.

(В чем разница между volatile и synchronized?) http://www.quizful.net/interview/java/volatile-vs-synchronized
-----------------------------------------------
"synchronized" - имеет два важных момента: это гарантия того, что только один поток выполняет секцию кода в один момент времени 
                 (взаимоисключение или mutex), и также гарантия того, что данные, изменённые одним потоком, будут видны всем другим потокам 
				 (видимость изменений).
"volatile"     - проще, нежели синхронизация и подходит только для контроля доступа к одиночному экземпляру или переменной примитивного 
                 типа: int, boolean... Когда переменная объявлена как volatile, любая запись её будет осуществляться прямо в память, минуя кеш. 
				 Также как и считываться будет прямо из памяти, а не из всевозможного кеша. Это значит, что все потоки будут "видеть" одно и то же 
				 значение переменной одновременно.


                                                                  (java.util.concurrent)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(MQX, Москва, 03.2011. Семафоры и мьютексы) http://www.youtube.com/watch?v=pdqI6DbcrmU
 -----------------------------------------
Поэтому что использовать в программе "семафоры" или "мютексы" зависит от конкретной ситуации и поставленой задачи:
"Семафор" ................. позволяет обеспечить контроль доступа для нескольких потоков к одному общему ресурсу и позволяет синхронизировать доступ к этому ресурсу нескольким задачам
"Семафоры" ................ работают в режиме пользователя, то есть, он блокирует именно задачи. Если задача захватила "семафор" и вошла в выполнения то ее может прекратить более
                            приоритетная задача (когда работает "семафор" - есть возможность работать планировщику задач)
"Мютекс" .................. работает в режиме ядра и блокирует сам ресурс. На время выполнения "мютекса" задача которая захватила "мютекс" получает максимальный приоритет. Если
                            задача захватила "мютекс" и вошла в выполнения то ее НЕможет прекратить никакая другая задача (только прерывание)
Например:
- случай когда требуется чтобы блокировку "симафора" прервала более приоритетная задача, какой-нибудь Exception пользовательское сообщение... при закрытии окна;
- в случае когда произойдет "deadlock" при работе с "мютексом" - тогда уже такую блокировку невозможно будет снять... любыми системными средствами;

"LightweightSemaphores" ... (легковестные симафоры) ограничены немного по ресурсам, но работают значительно быстрее в отличие от обычных симафоров и требуют меньше ресурсов
"Semaphores" .............. (поноценые симафоры)
"Mutexes" .................

                                                                  (java.util.concurrent) java.util.concurrent.Semaphore
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
"СЕМАФОР" — объект который, ограничивает количество потоков, что могут войти в заданный участок кода (семафоры используются при передаче данных через разделяемую память)

"Семафоры" (java.util.concurrent.Semaphore) - используются для того, чтоб перед использованием ресурса проверить его доступность.
Примером из жизни может служить тележка (общий ресурс) и два работника (потоки java). Один работник, к примеру, наполняет тележку песком. В это время второй работник, который
перевозит груз и затем разгружает, не может взять тележку и отвезти ее.

(Семафор (информатика)) http://ru.wikipedia.org/wiki/Семафор_(информатика)
 ---------------------
"Семафор" — объект, ограничивающий количество потоков, которые могут войти в заданный участок кода. Определение введено Эдсгером Дейкстрой.
"Семафоры" используются при передаче данных через разделяемую память.
"Двоичный семафор" — это объект, с которым можно выполнить 3-операции:
1. Может принимать значения "0" и "1", инициализируется значением "1";
2. Обеспечивает эксклюзивный доступ к ресурсу (например, при работе в критической секции);
3. Одновременно может выполняться только один поток;
В более сложных семафорах может использоваться очередь: при этом потоки, ожидающие освобождения семафора, будут проходить через семафор именно в том порядке, в котором они вызывали
enter().
Применение семафоров, вот некоторые из проблем, которые могут решать семафоры:
* запрет одновременного выполнения заданных участков кода;
* поочерёдный доступ к критическому ресурсу (важному ресурсу, для которого невозможен одновременный доступ).
Проблемы семафоров:
* Во-первых, можно написать программу с «утечкой семафора», вызвав enter() и забыв вызвать leave(). Реже встречаются ошибки, когда дважды вызывается leave().
* Во-вторых, семафоры чреваты взаимной блокировкой потоков.

(Высокоуровневые механизмы синхронизации) http://sham.16mb.com/wordpress/wp-content/uploads/2013/10/Section_7-8.pdf
 ---------------------------------------
Виды семафоров:
- "Двоичный семафор"
  1. Может принимать значения "0" и "1", инициализируется значением "1";
  2. Обеспечивает эксклюзивный доступ к ресурсу (например, при работе в критической секции);
  3. Одновременно может выполняться только один поток;
- "Счетный семафор"
  1. Инициализируется значением N (число доступных единиц ресурса);
  2. Представляет ресурсы, состоящие из нескольких однородных элементов;
  3. Позволяет потокам исполняться, пока есть неиспользуемые элементы;

(Семафоры. Синхронизация процессов * Системные вызовы Unix/Linux) http://life-prog.ru/view_linux.php?id=23
 ---------------------------------------------------------------
В ОС Unix/Linux механизм "семафоров" обслуживается 3-мя системными вызовами:
"semget" ... создает массив "семафоров" или возвращает идентификатор уже существующего "массива семафоров". Этот идентификатор используется при дальнейших операциях с "семафорами".
             Системные вызовы работают с "массивами семафоров", это сделано только лишь для того, чтобы иметь общую идентификацию для всех "семафоров" одной задачи.
             Системные вызовы "semctl" и "semop" дают возможность отдельно оперировать с каждым "семафором массива";
"semctl" ... позволяет выполнять управляющие операции над "массивом семафоров" и отдельными его элементами: читать и устанавливать значения, уничтожать "массив семафоров";
"semop" .... выполняет прикладные семафорные операции: аналоги P- и V-операций, а также проверки состояния "семафора";
  "Семафоры" в ОС Unix/Linux не имеют внешних имен. При получении "идентификатора семафора" процесс пользуется числовым ключом. Разработчики несвязанных процессов могут договориться
об общем значении ключа, который они будут использовать, но у них нет гарантии в том, что это же значение ключа не будет использовано кем-то еще. Гарантированно уникальный
"массив семафоров" можно создать с использованием ключа IPC_PRIVATE, но такой ключ не может быть внешним. Поэтому "семафоры" используются, как правило, родственными процессами,
которые имеют возможность передавать друг другу идентификаторы семафоров, например, через наследуемые ресурсы или через параметры вызова дочерней программы.

Внимание!
В процессе отладки программы у Вас могут возникать ситуации, когда программа будет аварийно заканчиваться или прерываться Вами прежде, чем она уничтожит созданные ею "семафоры".
Такие "семафоры" не удаляются в системе автоматически и могут накапливаться в течение многих дней. Накопление таких (забытых) "семафоров" может привести к тому, что будет исчерпан
системный лимит на количество "семафоров", и очередной вызов "semget" закончится с ошибкой. Для того, чтобы этого не происходило, регулярно выполняйте процедуру очистки IPC:
"/home/metod/rmipc". Выполняйте эту процедуру также перед каждым выходом из сеанса.

(5-вещей которые вы не знали о пакете java.util.concurrent) http://www.ibm.com/developerworks/ru/library/j-5things5/
 ---------------------------------------------------------
1. Семафор
   В некоторых корпоративных системах разработчикам нередко нужно ограничивать количество открытых запросов (потоков/действий), использующих определенный ресурс. На самом деле такое
   ограничение может иногда улучшить производительность системы, снижая конкуренцию за данный ресурс. Конечно, можно попытаться вручную написать осуществляющий регулировку код,
   однако легче использовать класс-"Semaphore", который позаботится о регулировке за вас.
2. CountDownLatch
   Если "Semaphore" – это параллельный класс, предназначенный для того, чтобы позволить потокам "заходить по одному" (возможно, напоминая "вышибал" из популярных ночных клубов), то
   "CountDownLatch" напоминает стартовый барьер на скачках. Этот класс задерживает все потоки до тех пор, пока не будет выполнено определенное условие. При выполнении условия он
   освобождает все потоки одновременно.
3. Executor
   Довольно досадным изъяном примеров является то, что в них необходимо явно создавать объекты класса "Thread". Это представляет повод для беспокойства, так как в некоторых JVM
   создание потока является дорогостоящей операцией, поэтому гораздо лучше повторно использовать существующие потоки, чем создавать новые. В то же время в других JVM все наоборот:
   потоки довольно легковесны и поэтому гораздо лучше при необходимости создать новый поток. Конечно, если Мёрфи (как обычно) окажется прав, какой бы подход вы ни предприняли, он
   окажется неправильным для платформы, на которой в итоге будет разворачиваться приложение.
   Вместо того чтобы вынуждать Java-разработчиков создавать потоки напрямую, они ввели интерфейс-"Executor" – абстракцию для получения новых потоков. "Executor" позволяет создавать
   потоки без самостоятельного использования оператора "new" для объекта "Thread".
4. ScheduledExecutorServices
   Интерфейс "ExecutorService" хорош, однако он не подходит для случая, когда некоторые задачи необходимо делать по расписанию, например выполнять что-то через определенные
   интервалы времени или в заданное время. Здесь пригодится класс-"ScheduledExecutorService", расширяющий класс "ExecutorService".
5. Тайм-ауты для методов
   Одним из главных преимуществ библиотеки "java.util.concurrent" перед своими предшественниками, такими как "мониторы" для блокировки, является возможность задавать тайм-ауты для
   блокирующих операций (что позволяет избежать взаимных блокировок).


                                                                  (java.util.concurrent)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
"МЬЮТЕКС" (Mutual) — это простейшие двоичные "семафоры", которые могут находиться в одном из двух состояний — открыт и закрыт (один из вариантов семафорных механизмов для организации
                     взаимного исключения. Они реализованы во многих ОС, их основное назначение: организация взаимного исключения для потоков из одного и того же или из разных процессов)

(Высокоуровневые механизмы синхронизации) http://sham.16mb.com/wordpress/wp-content/uploads/2013/10/Section_7-8.pdf
 ---------------------------------------
"Мьютекс" – это "двоичный семафор", обычно используемый для организации согласованного доступа к неделимому общему ресурсу. Мьютекс может принимать значения 1 (свободен) и 0 (занят).
Операции над мьютексами:
* "acquire(mutex)" ...... уменьшить (занять) мьютекс;
* "release(mutex)" ...... увеличить (освободить) мьютекс;
* "tryacquire(mutex)" ... часто реализуемая неблокирующая операция, выполняющая попытку уменьшить (занять) мьютекс;
Мьютексы в конкретных реализациях могут иметь дополнительные свойства:
* Запоминание владельца ..... освободить мьютекс может только поток, захвативший его
* Рекурсивность ............. поток может многократно захватить мьютекс (вызывать aquire()); для освобождения мьютекса поток должен соответствующее число раз вызвать release();
* Наследование приоритета ... поток, захвативший мьютекс, временно наследует максимальный из приоритет потоков, ждущих освобождения данного мьютекса

(Чем отличается критическая секция от мьютекса?) http://www.sql.ru/forum/945715/chem-otlichaetsya-kriticheskaya-sekciya-ot-muteksa
 ----------------------------------------------
По сути ведь "критическая секция" в Windows это тот же "мьютекс" перед которым сначала запускается на некоторое время "spinlock".
Есть только две особенности, очень важные:
1. "мьютекс" .............. объект ядра и он медленнее критической секции;
2. "критическая секция" ... принадлежит одному процессу, за счет этого она быстрая, но она не может работать в нескольких процессах, только в одном. У неё нет имени, только адрес, который определен в рамках одного процесса;

(Процессы и нити в ОС Linux) http://uinc.ru/articles/34/
 --------------------------
Почему mutex:
Как показывает практика правильно использовать его проще, чем другие механизмы синхронизации. На основе mutex и еще одного механизма, про который мы поговорим позже, легко построить все остальные механизмы синхронизации.
Кроме того, его легко и дешево реализовывать.

Использование mutex:
В программах написанных для OS Linux "mutex" представляется переменными типа "pthread_mutex_t". Прежде начать использовать объект типа "pthread_mutex_t" по назначению, то есть для синхронизации, необходимо провести ее
инициализацию. При этом возможно будут выделены какие-либо системные ресурсы (например, "pthread_mutex_t" может представлять собой всего лишь указатель на объект который представляет mutex и тогда при инициализации
"mutex'а" требуется выделение памяти под этот объект).

(FreeRTOS: мьютексы и критические секции) http://habrahabr.ru/post/129445/
 ---------------------------------------
Мьютексы:
  Рассмотрим ситуацию, при которой необходимо иметь совместный доступ к ресурсу (порт, область памяти, какая-либо переменная) да ещё так, чтобы в единицу времени только один таск мог обращаться к данному ресурсу, в то время
как остальные задачи, желающие получить доступ к ресурсу должны ждать своей очереди.
  На помощь приходит специальный тип семафора — мьютекс(mutex). Данная абстракция представляет собой своеобразный жетон, имея который, таск может иметь доступ к ресурсу, и который необходимо вернуть по окончанию работы с
ресурсом, причем вернуть «жетон» может только тот таск, который его взял.

(Про мьютексы * Программировать на мьютексах трудно) http://levin-matveev.livejournal.com/84750.html
 --------------------------------------------------
  Во-первых, непонятно, как эти мьютексы расставлять. Если ставить один большой мьютекс на всё, то будет медленно работать (другие потоки будут подолгу ждать освобождения мьютекса занимая место в пуле, и contention). Если
ставить много маленьких мьютексов, то надо следить не забыть захватить какой-нибудь мьютекс, и нужно следить, чтобы не возник deadlock.
  Во-вторых, у мьютексы (или спинлоки, неважно), страдают от contention.
  Если это обычный мьютекс, то захват мьютекса без contention занимает 5ns, а если есть contention, то захват/отпускание мьютекса занимает уже микросекунды (перфтест на вызов futex_wake, через который на линуксе работает
мьютекс в случае contention показывает 400ns на вызов).
  Спинлок в случае contention страдает тем, что пока один поток работает, другой поток греет процессор.
  Проблема и мьютексов, и спинлоков в том, что чем больше нагрузка в системе, тем их использование дороже — мьютекс начинает делать системные вызовы вместо оптимистических локов, а спинлоки начинают греть процессор.
  Хуже того, если по какой-то причине загрузка сервера равна 100% и велика очередь процессов на выполнение (когда load average больше числа ядер в системе), спинлоки могут греть процессор даже если в данный момент "критическую
секцию" никто не выполняет".
  Кроме того, мьютексы, а особенно спинлоки, плохо себя ведут, если система по какой-то причине останавливает поток, выполняющий критическую секцию (если случается свопирование, cache miss, доставка сигнала именно в этот поток,
аппаратное прерывание, шедулинг другого процесса на этот CPU и т. п.)



                                                                (java.util.concurrent.atomic) Атомарные объекты/операции
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(5 вещей, которых вы не знали о многопоточности) http://habrahabr.ru/post/108016/
 ----------------------------------------------
Обновления атомарных полей:
Когда вам требуется примитивный тип, выполняющий операции инкремента и декремента, гораздо лучше выбрать его среди новых атомарных классов в пакете java.util.concurrent.atomic,
чем писать synchronized блок самому. Атомарные классы гарантируют, что определённые операции будут выполняться потокобезопасно, например операции инкремента и декремента,
обновления и добавления(add) значения. Список атомных классов включает AtomicInteger, AtomicBoolean, AtomicLong, AtomicIntegerArray, и так далее.





-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(Особенности применения модификаторов в Java * Модификаторы доступа) http://www.quizful.net/post/features-of-the-application-of-modifiers-in-java
 ------------------------------------------------------------------
В Java существуют четыре модификатора доступа: "public", "private", "protected" и отсутствие модификатора (он же модификатор по умолчанию - default/package-private).
К невложенным классам и интерфейсам ................. применимы только два из них: "public" и модификатор по умолчанию (он же default/package-private).
К методам и полям класса ............................ применим весь набор.

  "public" члены .................................... доступны из любых методов любых классов. Наследуются любыми классами.
  "private" члены ................................... доступны только из этого же класса. Не наследуются. В (под)классе можно объявить точно такой же член, но это не будет являться переопределением.
  "protected" и "default" (package-private) члены ... в Java protected-уровень включает ещё и default, они полностью идентичны за исключением одной разницы:
                                                        "default-члены"   доступны только в классе внутри одного пакета. Не наследуются.
                                                        "protected-члены" доступны из этого же класса и всем (под)классам-наследникам внутри одного пакета.
Итого, последовательность модификаторов по убыванию уровня закрытости:
private < default < protected < public
.....................................................................................................................................................................................
(Java / Модификаторы доступа (области видимости)) http://www.quizful.net/interview/java/access-modifiers
 -----------------------------------------------
В Java существуют следующие модификаторы доступа:
  private ..................... члены класса доступны только внутри класса;
  default (package-private) ... (модификатор, по-умолчанию): члены класса видны внутри пакета (если класс будет так объявлен он будет доступен только внутри пакета);
  protected ................... члены класса доступны внутри пакета и в наследниках;
  public ...................... члены класс доступны всем;
.....................................................................................................................................................................................
(Модификаторы доступа в Java) http://www.javacore.ru/topic/item/77-core.htm
 ---------------------------
В языке Java предусмотрены следующие модификаторы доступа:
  public - общедоступный;
  protected - защищенный;
  private - закрытый;
  default - пакетный.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
(Java / Модификаторы доступа (области видимости)) http://www.quizful.net/interview/java/access-modifiers
 -----------------------------------------------

Наследование класса и создание екземпляра класса - это разные вещи:
  "Суперкласс" ......... это базовый класс
  "Подкласс" ........... это класс который наследуется и расширяет функционал "суперкласса", (класс-наследник)
  "Наследование" ....... это расширение функционал "суперкласса" в новом класс-наследнике на этапе его определения...
  "Екземпляр класса" ... это создание уже рабочего объекта от класса на этапе его объявления...
Доступ к элементам класса можно получить:
- и на этапе его определения (например: в "суперклассе" или в "классе-наследнике")...
- и на этапе его объявления (уже от рабочего объекта "екземпляра класса" - по ссылке на доступ)...

  "final" ....... можно использовать, когда вам необходимо не допустить наследования вашего класса.
                  это модификатор, позволяющий объявлять константные поля в классе. Если у вас есть некоторое свойство проектируемого вами объекта,
                  значение которого не будет меняться, то вы может воспользоваться этим модификатором. Любая попытка переопределить значение поля с
                  модификатором final приводит к выбросу исключения.
                  (То есть, модификатор "final" запрещает создавать класс-наследник для суперкласса. Создавать екземпляры этого класса можно в неограниченом количестве)
  "abstract" .... позволяет объявить класс неполноценным и не предназначенным для создания его экземпляров. Классы с таким модификатором можно только наследовать.
                  (модификатор "abstract" запрещает определять конструктор в классе ??? можно создавать конструкторы анутри abstract-ого класса)
                  abstract-ный класс - это каркас классов
  "interface" ... Интерфейс это консутрукция языка программирования Java, в рамках которой могут описываться только абстрактные публичные (abstract public) методы и статические константyst свойства (final static). То есть также, как и на основе абстрактных классов, на основе интерфейсов нельзя порождать объекты.
                  Один интерфейс может быть наследником другого интерфейса.
                  Классы могут реализовывать интерфейсы (т. е. получать от интерфейса список методов и описывать реализацю каждого из них), притом, что особенно важно, один класс может реализовывать сразу несколько интерфейсов.

                  Зачем сделано разделение понятий "интерфейса" и "абстрактного класса": IMHO кроется в отказе от множественного наследования в архитектуре JAVA, т.е. потомка можно создать на базе только одного класса, а имплементировать интерфейсов — сколько угодно. Т.о. таким странным образом JAVA эмулирует поддержку множественного наследования. (в C++ есть множественное наследование, там только "абстрактные классы" без "интерфейсов" в данном понимании).

  "static" ...... (+abstract для метода нельзя) могут быть только члены и Конструкторы, но не Классы. Доступ к таким членам Класса после инстанциирования происходит только по Типу экземпляра,
                  Тип значения в нем не важен. Внутри такого метода нестатический метод может быть вызван только используя инстанциирование Класса, содержащего этот нестатический метод.
                  Инициализируются поля единожды при инициализации Класса, запрещаются инициализации опережающими ссылками, в отличие от переменых экземпляра, в которых разрешается инициализация
                  опережающей ссылкой на статический член и слова this и super.
                  (То есть, модификатор "static" ограничивает количество создания только до 1-екземпляра этого класса)


// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //
"Класс" ............... представляет собой некий объект-сущность, который может иметь свое состояние (через поля класса) и описывает свое поведение (черех методы класса).

Если нужно создать какой-нибудь особый метод - для этого необизательно нужно делать наследование для определения новой сущности...

"Базовый класс" ....... обычно это есть библиотечны класс с уже оптимальным определением для своих методов которые будут использованы во всех остальных классах наследников.
"Абстрактный класс" ... в случае если для методов базового класса невозможно ранее предугадать однозначное определение.

(...) http://www.amse.ru/courses/oopjava/11.php
 ---
В Java (в отличие от некоторых других языков программирования) каждый класс, кроме Object, имеет ровно одного родителя. Такая политика позволяет избежать сложностей, связанных с зависимостями классов, но при этом создает некоторые неудобства.


http://www.sql.ru/forum/926638/v-chem-raznica-mezhdu-abstraktnym-klassom-i-interfeysom
ответ прост - любой класс может наследоваться от любого количества интерфейсов, но только одного класса. Во всем остальном приведенный выше код будет вести себя идентично.

Статические конструкторы (класса) http://crypto.pp.ua/2011/01/staticheskie-konstruktory-klassa/
О синглтонах и статических конструкторах http://habrahabr.ru/post/125421/
Что такое Singleton (Одиночка) http://habrahabr.ru/post/103681/
http://hashcode.ru/questions/27770/java-зачем-нужны-статические-не-вложенные-классы
По большому счету, все классы верхнего уровня ведут себя, как статические - т.е. вам ничего не нужно создавать перед тем, как инстанцировать их - так что необходимости в этом модификаторе нет и он не просто не поддерживается спецификацией.
4.1 Статические члены класса http://opensourcerules.net/java/gl4_1.html
Ключевые слова final и static http://rusio.net/java/final_static.php
Статические методы в Java, перегрузка методов, рекурсия http://kostin.ws/java/java-static-methods.html
Inner classes && Static inner classes http://javatalks.ru/topics/24400
Что такое static http://www.linkex.ru/java/static.php
Статические классы http://citforum.ru/internet/javaqa/javaqanda_14.shtml
Интерфейсы vs. классы http://habrahabr.ru/post/30444/
Java. Урок 28. Абстрактные классы и множественное наследование http://cybern.ru/java-abstract-classes.html
Чем абстрактный класс отличается от интерфейса http://wizardjava.com/java/chem-abstraktnyj-klass-otlichaetsya-ot-interfejsa
http://hashcode.ru/questions/43777/зачем-абстрактный-класс-в-java
Собственно главное отличие абстрактного класса от обычного заключается только в том, что у абстрактного класса невозможно создать объект и поэтому он предназначен только для переопределения
http://sh2533.blogspot.com/2013/05/blog-post.html
Абстрактный класс должен служить для определения общей функциональности объектов, а интерфейс должен описывать, через какие методы можно обращаться в объекту.
Абстрактные классы и методы. Интерфейсы. Множественное наследование интерфейсов http://kostin.ws/java/java-abstract-and-interfaces.html
http://idev.by/android/22629/
В силу отсутствия множественного наследования, к выбору между интерфейсом и абстрактным классом нужно относиться ответсвенно. Но это лишь одна из причин. Используя абстракный класс вы можете сделать вызов метода предка super и получать доступ к его protected полям, что может привести к нарушению инкапсуляции. Поэтому часто рекомендуют использовать вместо наследования композицию или делегирование. Но это рекомендации.
Таким образом, если классы действительно должны находиться в одной иерархической ветви, то есть разделюят общую функциональность и данные, а так же связаны логически по типу «is a» — абстрактный класс уместен. Если же из общего у классов только интерфейс, то «это как бы намекает», что тут уместен интерфейс.
http://www.quizful.net/interview/java/interface-vs-abstract-class
концептуальное различие: абстрактный класс (как и любой класс) описывает СУЩНОСТЬ т.е. "предмет", тогда как интерфейс описывает КОНТРАКТ (поведение или свойства в отрыве от самого предмета). Наследование(реализация) интерфейсов почти всегда предпочтительнее наследования классов, т.к. более гибко, и допускает множественность реализации (множественное наследование для классов в Java отсутствует).
Множественное наследование в Java . Сравнение композиции и наследования. http://info.javarush.ru/translation/2013/08/26/Множественное-наследование-в-Java-Сравнение-композиции-и-наследования-.html
Интерфейсы и внутренние классы http://www.ccfit.nsu.ru/~deviv/courses/oop/tij2nd/Chapter08.html
Глава 7 Классы http://www.softzenware.com/java/07.htm
// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

.....................................................................................................................................................................................
(Исследование Модификаторов Класса и Типов) http://spec-zone.ru/RU/Java/Tutorials/reflect/class/classModifiers.html
 -----------------------------------------
class может быть объявлен с одним или более модификаторами, которые влияют на его поведение времени выполнения:
  Модификаторы доступа: public, protected, и private
  Переопределение требования модификатора: abstract
  Ограничение модификатора одним экземпляром: static
  Модификатор, запрещающий модификацию значения: final
  Модификатор, вызывающий строгое поведение с плавающей точкой: strictfp
  Аннотации













Модификаторы static, abstract и final
    Static
        Применяется к внутренним классам, методам, переменным и логическим блокам
        Статические переменные инициализируются во время загрузки класса
        Статические переменные едины для всех объектов класса (одинаковая ссылка)
        Статические методы имеют доступ только к статическим переменным
        К статическим методам и переменным можно обращаться через имя класса
        Статические блоки выполняются во время загрузки класса
        Не static методы не могут быть переопределены как static
        Локальные переменные не могут быть объявлены как static
        Абстрактные методы не могут быть static
        Static поля не сериализуются (только при реализации интерфейса Serializable)

    Abstract
        Применяется только для методов и классов
        У абстрактных методов нет тела метода
        Является противоположностью final: final класс не может наследоваться, abstract класс обязан наследоваться
        Класс должен быть объявлен как abstract если:
        он содержит хотя бы один абстрактный метод
        он не предоставляет реализацию наследуемых абстрактных методов
        он не предоставляет реализацию методов интерфейса, реализацию которого он объявил
        необходимо запретить создание экземпляров класса

    Final
        Поля не могут быть изменены, методы переопределены
        Классы нельзя наследовать
        Этот модификатор применяется только к классам, методам и переменным (также и к локальным переменным)
        Аргументы методов, обозначенные как final, предназначены только для чтения, при попытке изменения будет ошибка компиляции
        Переменные final не инициализируются по умолчанию, им необходимо явно присвоить значение при объявлении или в конструкторе, иначе – ошибка компиляции
        Если final переменная содержит ссылку на объект, объект может быть изменен, но переменная всегда будет ссылаться на тот же самый объект
        Также это справедливо и для массивов, потому что массивы являются объектами, – массив может быть изменен, а переменная всегда будет ссылаться на тот же самый массив
        Если класс объявлен final и abstract (взаимоисключающие понятия), произойдет ошибка компиляции
        Только переменные final могут быть переданы в конструктор с параметрами, вызывающийся через слово super(//параметр//)
        Так как final класс не может наследоваться, его методы никогда не могут быть переопределены


(Java / Интерфейсы и абстрактные классы) http://www.quizful.net/interview/java/interface-vs-abstract-class
 --------------------------------------
 Абстрактные классы используются только тогда, когда есть "is a" тип отношений; интерфейсы могут быть реализованы классами которые не связаны друг с другом.

Абстрактный класс может реализовывать методы; интерфейс не может реализовывать методы.

Интерфейс может только описывать константы и методы, но не реализовывать их. Все методы интерфейса по-умолчанию являются публичными (public) и абстрактными (abstract), а поля - public static final.

В Java класс может наследоваться (реализовывать) от многих интерфейсов, но только от одного абстрактного класса.

С абстрактными классами вы теряете индивидуальность класса, наследующего его; с интерфейсами вы просто расширяете функциональность каждого класса.


(Абстрактные классы и методы. Интерфейсы. Множественное наследование интерфейсов) http://kostin.ws/java/java-abstract-and-interfaces.html
 -------------------------------------------------------------------------------
Интерфейс это консутрукция языка программирования Java, в рамках которой могут описываться только абстрактные публичные (abstract public) методы и статические константyst свойства (final static). То есть также, как и на основе абстрактных классов, на основе интерфейсов нельзя порождать объекты.

Один интерфейс может быть наследником другого интерфейса.

Классы могут реализовывать интерфейсы (т. е. получать от интерфейса список методов и описывать реализацю каждого из них), притом, что особенно важно, один класс может реализовывать сразу несколько интерфейсов.

Перед описанием интерфейса указывается ключевое слово interface. Когда класс реализуемт интерфейс, то после его имени указывается ключевое слово implements и далее через запятую перечисляются имена тех интерфейсов, методы которых будут полностью описаны в классе.

(Если "интерфейс" — чистая абстракция, то "класс" — чистое воплощение, а "абстрактный класс" застрял где-то по середине) http://www.rsdn.ru/forum/java/1502379.hot
 -----------------------------------------------------------------------------------------------------------------------
Зачем сделано разделение понятий "интерфейса" и "абстрактного класса": IMHO кроется в отказе от множественного наследования в архитектуре JAVA, т.е. потомка можно создать на базе только одного класса, а имплементировать интерфейсов — сколько угодно. Т.о. таким странным образом JAVA эмулирует поддержку множественного наследования. (в C++ есть множественное наследование, там только "абстрактные классы" без "интерфейсов" в данном понимании).

(Множественное наследование в Java . Сравнение композиции и наследования) http://info.javarush.ru/translation/2013/08/26/Множественное-наследование-в-Java-Сравнение-композиции-и-наследования-.html
 -----------------------------------------------------------------------



































////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
"abstract" ... позволяет объявить класс неполноценным и не предназначенным для создания его экземпляров. Классы с таким модификатором можно только наследовать.

При объявлении класса вы можете использовать сразу несколько модификаторов. Из их определений можно заметить, что единовременно нельзя использовать модификаторы final и abstract по
причине их противоположности.



- final ...... (+volatile для поля и +abstract для метода нельзя). Такие Классы не могут иметь более Наследников и следовательно все их члены не могут учавствовать в родопродолжении.
               Члены в нефинальных Классах при продолжении рода не могут быть Скрыты,Перекрыты, Нельзя изменить их Начальные Значения. Члены Класса Обязаны инициализироваться при объявлении.
               Статические final переменные инициализируемые постояными значениями инициализируются первыми так как final поле не изменяемое, то Запрещены приведения полей к типу final поля.
- static ..... (+abstract для метода нельзя) могут быть только члены и Конструкторы, но не Классы. Доступ к таким членам Класса после инстанциирования происходит только по Типу экземпляра,
               Тип значения в нем не важен. Внутри такого метода нестатический метод может быть вызван только используя инстанциирование Класса, содержащего этот нестатический метод.
               Инициализируются поля единожды при инициализации Класса, запрещаются инициализации опережающими ссылками, в отличие от переменых экземпляра, в которых разрешается инициализация
               опережающей ссылкой на статический член и слова this и super.
- abstract ... (+private, static, final, native или synchronized для метода нельзя ) М.б. только Классы и методы (поля не могут).
- Все элементы интерфейсов являются неявно public(хоть сами интерфейсы могут иметь доступ по-умолчанию) :
               (Interface - специфицирует абстрактные услуги, предоставляемые классом или компонентом, он позволяет рассоединить части программной системы в модули без взаимной зависимости кода
               и общаться им на понятном языке;
                 Абстрактный класс - класс, содержащий хотя бы один абстрактный метод, его можно рассматривать в качестве интерфейса к семейству классов, порождённому им, но, в отличие от интерфейса,
               он может иметь уже реализованное методы,(которые, кстати, в особенных ситуациях могут перекрываться в его Потомках абстрактными). В Java (в отличие от некоторых др.языков) класс
               обязан квалифицироваться абстрактным при наличии хоть одного абстрактного метода. Экземпляры Абстрактных типов нельзя создать через new, но их можно определить в программе и присвоить
               им значения экземпляров Классов, являющихся Потомками этих Абстрактных типов и реализующих их абстрактные методы).
- Модификатор abstract для интерфейса не требуется, поскольку все интерфейсы являются абстрактными. Его можно указать, но делать этого не рекомендуется, чтобы не загромождать код.
               Чтобы новый класс мог быть объявлен неабстрактным, в нем должны быть реализованы все абстрактные методы, появившиеся при наследовании от интерфейсов или родительского класса;
- Все поля интерфейса являются public final static, так что эти модификаторы указывать необязательно и даже нежелательно, чтобы не загромождать код. Но ПОЛЯ следует инициализировать при определении.
- Все методы интерфейса являются public abstract и эти модификаторы также необязательны.



К локальным переменным можно применять только final.
Non-access модификаторы для членов класса
final для метода предотвращает переопределение в подклассах.
final для аргумента метода означает, что переменной присвоить новое значение.

Если в классе есть хотя бы один abstract-метод, то класс доджен быть объявлен с модификатором abstract.
Метод не может быть одновременно и abstract и final.
Метод не может быть одновременно и abstract и private.
Метод не может быть одновременно и abstract и static.

Конструктор не возвращает значение.
Конструктор не может быть static, final или abstract (т.к. его нельзя переопределить).


(Статические конструкторы (класса)) http://crypto.pp.ua/2011/01/staticheskie-konstruktory-klassa/
 ---------------------------------
Класс может иметь максимум один статический конструктор, и этот статический конструктор не может принимать параметров. Статические конструкторы никогда не вызываются напрямую.
Вместо этого CLR вызывает их, когда нужно инициализировать тип для данного домена приложения. Статический конструктор вызывается перед первым созданием экземпляра данного класса или перед первым обращением к любому из статических полей этого класса.

(Статические конструкторы и взаимоблокировка) http://habrahabr.ru/post/125421/
 -------------------------------------------

(Singleton (Одиночка) или статический класс) http://habrahabr.ru/post/103681/
 ------------------------------------------
Статический класс не поддерживает данной возможности ввиду того, что нельзя создать экземпляр статического класса.
Время жизни статического класса ограничено временем жизни домена — если мы создали этот домен вручную, то мы косвенно управляем временем жизни всех его статических типов.
Основное отличие статического класса от обычного, нестатического, в том, что невозможно создать экземпляр этого класса с помощью оператора new. Статические классы по сути являются некой разновидностью простанства имен — только в отличие от последних предназначены для размещения статических переменных и методов а не типов.

(java - Зачем нужны статические не вложенные классы?) http://hashcode.ru/questions/27770/java-зачем-нужны-статические-не-вложенные-классы
 ---------------------------------------------------
По большому счету, все классы верхнего уровня ведут себя, как статические - т.е. вам ничего не нужно создавать перед тем, как инстанцировать их - так что необходимости в этом модификаторе нет и он не просто не поддерживается спецификацией.
просто такая конструкция не поддерживается в java. Однако это не отменяет того факта, что статический класс (как паттерн) в java присутствует. Достаточно написать ненаследуемый класс с закрытым конструктором.

(Статические члены класса) http://opensourcerules.net/java/gl4_1.html
 ------------------------
Статические переменные - переменные, созданные с ключевым словом 'static'. К статическим переменным класса обращаются только статические методы. Есть только одна копия статической области на класс - независимо от того, сколько экземпляров класса создано.
Блок инициализации - блок кода между фигурными скобками, который выполнен прежде, чем будет создан объект класса. Статический блок инициализации - определенный блок, использующий ключевое слово, static, он выполняется один раз, когда загружается класс и может только инициализировать статических членов данного класса.

(Статические методы в Java, перегрузка методов, рекурсия) http://kostin.ws/java/java-static-methods.html
 -------------------------------------------------------
В объектно-ориентированном программировании основная задача методов заключается в том, чтобы изменять текущее состояние объекта, но до тех пор, когда в программе объекты ещё не используются, методы уже могут вводиться. Метод, который описан внутри некоторого класса, но вызывается без приложения к конкретному объекту этого класса, называется статическим

(Статические классы) http://citforum.ru/internet/javaqa/javaqanda_14.shtml
 ------------------
Вложенный верхнего уровня. Вложенный класс верхнего уровня это компонентный класс с модификатором static. Вложенный класс верхнего уровня такой-же, как и любой другой класс верхнего уровня, но он объявлен внутри другого класса или интерфейса. Вложенные классы верхнего уровня обычно используются как удобный способ для объединия родственных классов без создания нового пакета.
Одно важное замечание: ключевое слово static не делает с заголовком класса тоже, что с заголовком пременной или метода.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





??? (Многопоточность в Java) http://movejava.blogspot.com/2013/06/javautilconcurrentsemaphore.html
??? (Learn programming by doing examples.) http://programmingexamples.wikidot.com/mutex

(java методы без модификатора доступа)
  http://cybern.ru/java-access-modifiers.html
* http://www.nestor.minsk.by/kg/2002/18/kg21806.html
  http://www.sql.ru/forum/652995/shpargalka-po-modifikatoram-dostupa-v-java-pokritikuyte-plz
(java модификатор доступа по умолчанию)
* http://habrahabr.ru/post/132962/
* http://amazing-forum.ucoz.ru/forum/85-79-1
  http://itlift.ru/category/java/access_modifiers.print
  http://dr-magic.blogspot.com/2009/05/java-se-3.html

(java class static)
http://javapd.blogspot.com/2010/01/static-19.html
http://javatalks.ru/topics/12601?page=1#59226
http://www.litvinuke.hut.ru/articles/Java08.htm
http://otvety.google.ru/otvety/thread?tid=63862bbd1cac31da
http://cybern.ru/java-static-final.html




























