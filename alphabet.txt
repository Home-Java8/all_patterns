                                                                               Как работает наследование
                                                                               =========================
http://habrahabr.ru/post/30444/
-------------------------------
> Именно так и пишут Гамма и др.: наследование является нарушением инкапсуляции.
> Правильный подход к данному вопросу — отделить интерфейс от реализации. Во многих современных языках для этого предусмотрен специальный синтаксис. В отсталых языках можно
  использовать хаки, например,...
> Что касается наследования классов, которое, как вы помните, нарушает инкапсуляцию — часто вместо наследования лучше использовать делегирование и композицию.

http://www.amse.ru/courses/oopjava/11.php
-----------------------------------------
> В Java (в отличие от некоторых других языков программирования) каждый класс, кроме Object, имеет ровно одного родителя. Такая политика позволяет избежать сложностей,
  связанных с зависимостями классов, но при этом создает некоторые неудобства.

http://idev.by/android/22629/
-----------------------------
> В силу отсутствия множественного наследования, к выбору между интерфейсом и абстрактным классом нужно относиться ответсвенно. Но это лишь одна из причин. Используя
  абстракный класс вы можете сделать вызов метода предка super и получать доступ к его protected полям, что может привести к нарушению инкапсуляции. Поэтому часто рекомендуют
  использовать вместо наследования композицию или делегирование. Но это рекомендации.
> Таким образом, если классы действительно должны находиться в одной иерархической ветви, то есть разделюят общую функциональность и данные, а так же связаны логически по
  типу «is a» — абстрактный класс уместен. Если же из общего у классов только интерфейс, то «это как бы намекает», что тут уместен интерфейс.

http://www.sql.ru/forum/926638/v-chem-raznica-mezhdu-abstraktnym-klassom-i-interfeysom
--------------------------------------------------------------------------------------
> ах да, у абстрактного класса может быть конструктор по умолчанию который не можем объявить абстрактным:) в отличии от интерфейса. Но ответ ожидали другой, что любой другой
  класс может реализовать сколь угодно интерфейсов, а ведь вопрос был задан в чем различие между абстрактным классом и интерфейсом при условии аналогичных сигнатур класса.
  Понятно, что если бы намекнули туда куда клонят, то ответ был бы очевиден, тогда не пришлось бы отвечать :)

http://info.javarush.ru/translation/2013/08/26/Множественное-наследование-в-Java-Сравнение-композиции-и-наследования-.html
--------------------------------------------------------------------------------------------------------------------------
> Множественное наследование – способность создавать классы с множеством классов — родителей. В отличии от других популярных объектно-ориентированных языков, вроде С++, язык
  Java — не поддерживает множественное наследование классов. Не поддерживает он его из-за вероятности столкнуться с «проблемой алмаза» и вместо этого предпочитает
  обеспечивать некий комплексный подход для его решения, используя лучшие варианты из тех, которыми мы можем достичь аналогичный результат наследования.
> Композиция как спасение
  Так что же делать, если мы хотим использовать функцию methodA() класса ClassA и methodB() класса ClassB в ClassС? Решением этого может стать композиция – переписанная
  версия ClassC реализующая оба метода классов ClassA и ClassB, также имеющая реализацию doSomething() для одного из объектов.

http://www.rsdn.ru/forum/java/2652049.flat
------------------------------------------
> "Конструкторы не относятся к категории методов и не наследуются". Арнольд, Гослинг, Холмс.

==============================================================================================================================================================================
> (Механизм) Наследование классов применяется в случае когда нужно либо переопределить метод базового класса либо объеденить другие методы с базовым классом...
> Доступ к методу/конструктору/полю базового класса выполняется через (оператор) "super"

// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //
(Сводная таблица) http://idev.by/android/22629/
 ---------------
(Критерий сравнения)                (Абстрактный класс)	                                                 (Интерфейс)
Наследование 	                    Любой класс может наследовать только один абстрактный класс. 	     Любой класс может реализовывать (имплементировать, наследовать) множество интерфейсов.
Модификаторы доступа методов 	    К неабстактным членам класса применимы любые модификаторы. НО!       Методы в интерфейсе могут иметь модификаторы только public и abstract.
                                    Абстрактные методы (имеющие модификатор abstract) могут иметь        По умолчанию они уже public abstract.
                                    модификатор либо public, либо protected. То есть абстрактные
                                    методы не могут быть приватными (ну да, а смысл?).
Данные 	                            Абстрактный класса может содержать любые поля: статические и         Интерфейс может содержать только общедоступные константы
                                    экземплярные, константы, private/protected/public.                   (public final static int NOT_PI_CONST = -1);
Наличие реализации 	                Абстактный класс допускает реализацию методов. 	                     Интерфейс не может содержать никакой реализации методов.
Возможность описать конструктор 	В абстрактом классе можно описать конструктор (или несколько         В интерфейсе нельзя описать конструктор.
                                    конструкторов).

(Чем абстрактный класс отличается от интерфейса) http://wizardjava.com/java/chem-abstraktnyj-klass-otlichaetsya-ot-interfejsa
 ----------------------------------------------
(Критерий сравнения) 	(Абстрактный класс) 	                                        (Интерфейс)
Наследование 	        Любой класс может наследовать только один абстрактный класс 	Любой класс может реализовывать множество интерфейсов
Реализация 	            Абстрактный класс может реализовывать методы 	                Интерфесы только описывают методы, реализовывать нельзя
Данные 	                статические, константы, private/protected/public 	            Только public final static
Модификаторы доступа 	Все модификаторы доступа, кроме private 	                    Можно не писать, т.к. по умолчанию они public и abstract
Конструктор 	        В абстрактном классе можно создать конструктор 	                В интерфейсе нельзя создавать контсрукторы

(Интерфейсы vs. классы) http://habrahabr.ru/post/30444/
 ---------------------
Именно так и пишут Гамма и др.: наследование является нарушением инкапсуляции.
Главное отличие класса от интерфейса — в том, что класс состоит из интерфейса и реализации.
Любой класс всегда неявно объявляет свой интерфейс — то, что доступно при использовании класса извне. Если у нас есть класс Ключ и у него публичный метод Открыть, который вызывает приватные методы Вставить,
Повернуть и Вынуть, то интерфейс класса Ключ состоит из метода Открыть. Когда мы унаследуем какой-то класс от класса Ключ, он унаследует этот интерфейс.

(Почему конструкторы не наследуются) http://www.rsdn.ru/forum/java/2652049.flat
                     (Подводя итоги) http://www.javable.com/javaworld/10_00/01/
 (Различия в использовании интерфейсов и абстрактных классов) http://www.quizful.net/post/razlichie_v_primenenii_interfeysov_i_abstraktnih_klassov
// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //
> Если конструктор описан в базовом классе-родителе - тогда его нужно заюзать в классе-наследнике (инначе компилятор будет ругаться)
> приватные методы НЕнаследуются (наследуются только публичные и протектед методы)
  но из класса-наследника можно вызвать публичный метод который будет вызывать те приватные методы что были определены в базовом классе-родителе
// // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //