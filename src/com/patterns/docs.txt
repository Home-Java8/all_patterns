............................................................................................................................................................................
                                                   Подход к языку програмирования
                                                   ------------------------------
1))) Базовые элементы
Базовыми элементами в языке программирования являются низкоуровневые операторы, например:
    типовые операторы
        "int", "char", "byte", "boolean", "long", "short"
        "new", "class", "interface", "abstarct"
    модификаторы доступа
        "public", "private", "protected", "static", "final"
    логические операторы
        "+", "-", "*", "/", "%", "^", "=", "+=", "-=", "<", ">", "!", "<=", ">=",  "==", "!=", "&&",  "||", "?/:"
    побитовые операторы
        "<<", ">>", ">>>"
    условные операторы (выражения)
        "if/else", "switch/case/breack", "for/while", "try/catch/finally", "import", "package"
    (другие операторы)
        "throws", "extends", "implements"

Оператор - это специальная макро-команда, которая интуитивно выполняет ряд машинных микро-операций на физическом уровне...
Одни операторы служат для того чтобы создавать (виделять область) определенный тип (структуру) объектов в оперативной памяти...
Другие операторы служат для того чтобы выполнять логические операции над данными (складывать числа, делать контенацию строк, приведить типы данных, сравнивать значения)...
Третие операторы служат для выполнения законов объектно-ориентированного программирования...
А каждая строка кода состоящая из операторов - является инструкцией программы, которая поддерживает свой синтаксис и выполняется с конца (с права на лево)

Таким образом, если в спецификации языка программирования указано назначение конкретного оператора - это значит что все по спецификации микро-команды полностью будут выполнены.
Например:
- "extends" - по законам ООП выполнит наследование/полиморфизм/инкапсуляцию (по инструкциям в коде...)
- "new", "class" - выделит в оператовной области памяти место и физически создаст в нем определеную структуру объекта...
- "=" - выполнит приведение физического значения из оперативной и присвоит его переменной (и если нужно машинально микро-команда выполнит приведение типов "A=A")...

2))) Расширенные элементы
Возможности объектно-ориентированного языка программирования позволяют переопределять-создавать новые типы данных и высокоуровневые команды (функции).
Например:
- собственная структура классов с конкретным поведением
- определять собственные высокоуровневые операторы

Паттерны проектирования - это программная модель по реализации конкретной задачи.
Подход к программированию через паттерны проектирования обеспечивает высокую надежность работы программы.
Все пользовательские (высокоуровневые) библиотеки в ООП-языке программирования разработы с помощью паттернов проектирования.
И даже клиентский GUI-интерфейс (и его элементы) также разработы на базе паттернов проектирования.

- Чтобы увеличить скорость обработки данных и сэкономить траты времени на выполнение программы - для этого в приложениях используется
многопоточность, которая реализованы с помощью классов "Runnable" и "Thread".
- Но когда используется многопоточность, в приложениях теряется целостность данных при доступе к общему рессурсу данных. И чтобы
сохранить целостность данных для общих рессурсов в многопоточных приложениях - для этого применяется механизм синхронизации
(synchronized).
- Недостатком такого механизма синхронизации (synchronized) является низкая скорость обработки данных с общим рессурсом (по той причине
что часть задач периодически приостанавливается, но в целом многопоточные приложения работают намного быстрее...) и понижения стабильности
работы программы по причине появления возможных взаимных блокировок (deadlock).
Поэтому чтобы обеспечить надежность для работы многопоточных приложений (исключить возможные ситуации взаимных блокировок) применяются:
"Мютексы" и "Симафоры" (Mutex, Semafor).
- Но "Мютексы" и "Симафоры" обычно используются для работы с примитивными типами данных (и для разработки больших программ со сложными
типами данных, например списки, они все еще очень сложны в применении...). Поэтому для таких целей существуют стандартные библиотечные
классы "Concurrent", которые можно легко применять для реализации больших задач со стандартными списками (сложных) данных.
- Но даже при использовании стандартных библиотечных классов "Concurrent" для многопоточных приложениях наблюдаются утери в многопоточных
процессах. Все дело в том, что разные процессы тратят разное врремя на выполнения своих задач, и очень часто наблюдаются случаи
когда часть завершенных процессов простаивает, в то время когда другие процессы еще работают - неэффективное распределение нагрузки
на многопоточные задачи... Это особенно ощутимо при обработки большого объема данных где время измеряется в часах. Имеено для таких
целей существуют другие более эффективные библиотеки-фреймворки: "Hadoop/MapReduce", "Fork/Join" (которые уже распределяют нагрузку
между многопоточными процессами...).
   Недостаток всех таких библиотечных фреймворков в том что они используются только для конкретного-единичного случая, потому-что он реализован на низком уровне.
И каждая его функция прошла уже многолетнюю проверку, для их применения в современных программах. Такой подход есть очень неэффнетивным и сложным.

3))) Высокоуровневые элементы
Современные программы разрабатываются только на основе использования (высокоуровневых) библиотек языка прграммирования.

- Дело в том что все эти библиотечные классы и фреймворки обычно работают со стандартными типами данных (примитивные типы, списки...).
   А что делать в случаях когда нужно использовать (нестандартный) свой-специфический (сложный) тип объектов-данных, например: объекты игры.
Поэтому для таких целей существует техгология "MPI" (Message Passing Interface) для параллельныого вычисления - когда процессы,
обменивающиеся сообщениями. Такая "MPI" технология позволяет более надежно синхронизировать процессы в многопоточных приложениях
(избежать взаимных блокировок), и самое главное позволяет гибко работать с самыми разными (нестандартными) типами сложных объектов.
   Технологии типа "MPI", "OpenMP" они реализованы уже на высоком уровне и являются более простыми для применения...
(На базе такой технологии существуют даже специально разрабатываемые библиотеки для решения самых разных задач, например, математические пакеты: от поставщика Mathworks
"MATLAB", "LabVIEW")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                   Процессорное устройство
                                                   -----------------------
"Процессорное устройство" - это полностью автономное устройство, которое состоит из:
- контроллера (логические ключи + тригеры исполнительных узлов)
- опертивной системы (внутренней программы)
Такая (внутренняя) программа опертивной системы - является машинной программой - "драйвером" - которая управляет состоянием внутри такого процессорного устройства.
Такое процессорное устройство имеет разные режимы работы, например: инсталляция-перепрошивка-обновление драйвера (программы опертивной системы), загрузка данных пользовательских
инструкций, запуск-выполнение пользовательских инструкций, управление пользовательской программой в процессе ее выполнения, ...
   Программа (внутренней опертивной системы) драйвера - представляет собой машинную программу, которая писалась на машином языке программирования. Обычно процесс программирования
драйвера основывается на работе с системными регистрами (это специальные области памяти которые резервируются для выполнения специальных операций-комманд...). В Программе драйвера даже
не используются машинные микро-комманды (скорее всего такие комманды являются псевдо-машинными микро-командами). Потому-что псевдо-машинные микро-команды драйверов не имеют
определенного стандарта (обычно сам производитель это решает для себя).
   Но для управлениям таким "процессорным устройством" уже существовал специальный стандарт (внешних) машинных микро-комманд.
(Машинная программа - это последовательные комбинации двоичного 8-о, 16-о, 32-о, 64-о кода)
                                                   Многопроцессорные вычислительные устройства
                                                   --------------------------------------------
   Существовали также и внешние машинные программы, которые писались на машинных языках программирования, именно они (внешние машинные программы) уже использовали стандартные (внешние)
машинные микро-комманды - обычно такими внешними машинные микро-комманды являлись данные пользовательских инструкций, с помощью которых можно было писать небольшие (программные)
"системные утилиты" для многопроцессорных вычислительных устройств.
   Машинные программы "системные утилиты" и "драйвера" - пишутся на машинномм языке программирования, но способ написания таких машинных программ отличается...
Программа "драйвера" вместо машинных микро-комманд использует системные регистры (псевдо машинные микро-комманды, потому-что здесь нет стандартных машинных микро-комманд).
Программа "системной утилиты" использует (загружает) данные пользовательских инструкций, которые уже являются (внешними) машинными микро-коммандами.
   Такие многопроцессорные устройства были связаны между собой (внешней) шинной данных, по которой выполняется обмен данными (загрузка машинных программ). Такой подход позволял
писать небольшие системные утилиты для многопроцессорных устройств на (стандартном) машинном языке программирования.
(Все современные вычислительные устройства являются - многопроцессорными устройствами...)
                                                   Низкоуровневые языки программирования
                                                   -------------------------------------
Но написать какую нибудь большую-мощню (программу) системную утилиту на машинном языке программирования было трудно. Поэтому появились низкоуровневые языки программирования - "Ассемблер".
Низкоуровневый язык программирования ассемблер - представляет собой обычный набор макро-комманд (это определенный порядок машинных микро-комманд для выполнения полного цикла операции
законченного действия...). Другими словами, это прийнятый стандарт уже человеко-понятных названий макро-комманд для выполнентя полного цикла конкретной (сложной) операции.
   Для того чтобы выполнять уже макро-команды таких низкоуровневых программы (написанные на языке ассемблера) - существовали специальные (устройства) дизассемблеры, которые из
макро-комманд генерили специальный набор машинных микро-команд.
   Если машинные программы выполняются сразу после загрузки данных (пользовательских инструкций) в процессорное устройство. То для выполнения низкоуровневых программ нужно
(пройти 2-этапа) сперва перевести (с помощью дизассемблера) низкоуровневые макро-комманды в набор машинных микро-команд и только уже потом приступить к выполнению этой программы.
   На низкоуровневых языках программирования, обычно, писали "объектный код" - это и есть так называемая переносимое программное обеспечение (то есть, согласно прийнятому стандарту,
низкоуровневая программа должна быть совместимой и корректно работать на любом многопроцессорном вычислительном устройстве). А дизассемблированием, этапами такой
подготовки-загрузки для выполнения низкоуровневых программ выполняет "центральный процессор"...
С помощью низкоуровневых языков программирования уже можно писать (простые) "дисковые операционные системы". Но писать какие-нибудь большие программы все еще было сложно...
                                                   Высокоуровневые языки программирования
                                                   --------------------------------------
Первыми высокоуровневыми языками программирования являются - "процедурные языки программирования". Идея процедурного языка программирования заключается в повторном использовании
программного кода, который был один раз написан (многоразовый вызов функции-процедуры...).
   Дело в том, что на тот момент уже существовало написано много разного низкоуровневого программного кода, примеры которых можно было применять в разных-других случаях. Поэтому
случаю, можно собирать уже готовые решения программных библиотек, которые разработчики смогут повторно использовать в своих целях... (и экономить свое время на разработку).
Для этой цели существовал специальный (инструмент) "компановщик", с помощью которого можно было связывать (копировать-вставлять существующий программный код) программные библиотеки для
повторного использования в своих высокоуровневых процедурах-функциях. Но для выполнения таткой высокоровневой программы нужно выполнить уже несколько подготовительных операций:
связать-заменить свои функции (высокоуровневые комманды) библиотечным программным кодом; сгенерить (переносимое программное обеспечение) объектный код; дизассемблировать низкоуровневую
программу; и наконец выполнить ее...; Для выполнения всех этих подготовительных этапов служит специальный инструмент - "компилятор".
   Такой подход к программированию уже упрощал разработчикам писать большие программы и сложные "дисковые операционные системы". Несмотря что недостатком высокоуровневых языков
программирования есть медленная скорость подготовки программы к выполнению..., но основным достоинством высокоуровневых языков программирования является возможность писать
большие программы.
                                                   Другие типы программ
                                                   --------------------
"Дисковые операционный системы" состоят из:
- программного менеджера (который управляет задачами загрузкой, выгрузкой, запуском-выполнением программ, а также инсталляцией дополнительного программного обеспечения, настройкой
для пользовательского профиля... и выступает в роли оператора для подготовки рабочей станции пользователю...)
- пользовательских приложений (которые пользователь использует в работе для своих ежедневных задач)
- дополнительные API-библиотеки (которые применяются в программах для работы, например: с графикой, со звуком, устройствами ввода, ...)
   Размер современных программ (с прорисовкой своих графических элементов, звуковым сопровождением, элементами подсказки, и поддержкой других дополнительных различных функциональных
возможностей) имеет очень большой. И чтобы установить такую программу в системе на компьютере требуется много данных... Но дело в том, что современные "дисковые операционный системы"
уже имеют большую часть библиотечных компонентов, которые нужно для таких программ. Идея в том, чтобы для современных программ использовать уже доступные библиотечные рессурсы внутри
"дисковые операционный системы" - это приведет к тому что часть рессурсов для современных программеых можно отделить и неносить вместе с самой программой... Такие, урезанные, современные
программы называются - "приложениями" (потому-что частично они является частью "дисковой операционной системы", без которой не могут работать).
   Чтобы выполнить такое "приложение" нужно пройти еще больше этапов подготовки программ:
- (проверить синтаксические ошибки)
- перевести приложение в (низкоровневый) объектный код
- подключить пользовательские библиотеки
- скомпановать (собрать) элементы программы (если много-файловая стрктура)
- собрать программу в исполниьельный файл (архив) с привязкой к системной библиотеке

До этого момента мы говорили об компилируемых программах. Существуют еще и интерпретируемые приграммы.
   "Скрипт" - это высокоуровневая программа, которая выполняется с помощью приложения (то есть, это - интерпретируемая приграмма).
Достоинством при работе со скриптами (интерпретируемыми приграммами) в том, что ненужно заботится об этапах подготовки программы..., как в случае с компилируемыми программами, то есть,
они (скрипты) готовы к немедленному выполнению (как и в случае с машинными программами).
Недостатком всех скриптовых программ является медленная скорость их выполнения.
                                                   Особенности языка програмирования
                                                   ---------------------------------
Для лучшего понимания сути проблемы сравним напримере (системный язык программирования) "С++" и (кроссплатформенный язык программирования) "JAVA".

- Системный язык программирования "С++" используется для написания (локальных) системных приложений, которые работают обычно под управлением "дисковых операционных систем"
(а также системных утилит и драйверов...). Данные такого (локального) системного приложения представляет собой специальный архивный исполнительный файл (со специальным типом
расширения, который распознает операционная система). Все файлы (в том числе и исполнительные файлы приложений) хранятся на файловой системе локального носителя информации
в виде файлов... Внутри такого исполнительного архивного файла лежит собранный-скомпанованный (низкоуровневый) "объектный код". Дисковая операционная система (в свою очередь)
читает-извлекает содержимое исполнительного архивного файла ("объектный код") и передает его "центральному процессору" для дизассемблирования и дальнейшего выполнения этой
системной программы...
   То есть, на локальном компьютере все приложения-программы могут хранится только в форме файла (в файловой системе) на носителе информации, из которого потом извлекается
объектный код, выполняется поиск основной функции запуска для всей программы "main", (загружается в область опертивной памяти) обрабатывается "центральным процессором"
и выполняется (машинная програма)...
  Чтобы выполнить такое системное приложение (это высокоуровневый язык програмирования... процедурный или объектно-ориентированный) разработчик должен выполнить
следующие подготовительные этапы:
1. Скомпановать-собрать программные компоненты ("компановщик" - позволяет повторно использовать программный код..., заменить в коде вызываемые процедуры на библиотечными программами)
2(a). Получить-скомпилировать свое системное приложение в (конечный) объектный код
2(b). И запаковать его в специальный (для дисковой операционной системы) исполнительный файл...
2(c). Здесь важно понимать что (в этом случае) наш "исполнительный файл" - является одной законченно программой, которая содержит-укомплектована уже все требуемые для работы
      программные компоненты...
3. ...Задекларировать используемые типы данных (согласно этой информации "дисковая операционная система" выделит соответствующий размер в области оперативной памяти под
   данные для этой программы...);
4. ...Определить прототип структуру для типа-объекта (именно по этим данным "дисковая операционная система" создаст экземпляр такой программы, таких экземпляров может быть
   сколько угодно, и загрузит эти данные в уже ранее выделенную область оперативной памяти...);
5. ...Загрузить в уже ранее выделеную область оперативной памяти экземпляр такой программы-приложения и начать выполнять ее...;
И только после выполнения всех этих этапов для системного приложения можно подготовить требуемые для его работы условия, чтобы отдать программу на выполнение...

- Кроссплатформенный язык программирования "JAVA" используется для написания специальных-кроссплатформенных Java-приложений, которые работают под управлением "JVM"
(виртуальной машины JAVA).
   Среда "JVM" (виртуальная машина JAVA) в какой-то степени иммитирует-эмулирует работу "дисковой операционной системы". Данные такого Java-приложения хранятся в среде "JVM"
в виде классов (тип данных...), который и является исполнительным типом внутри среды "JVM". "JVM" извлекает байт-код из таких классов, выполняется поиск основной
функции-метода запуска для всей программы "main" и выполяет его.
   Дело в том, что Java-приложения это кроссплатформенные объекты, которые загружаются как пакеты данных по сети и-нет и хранятся в среде "JVM" в виде классов.
  Чтобы выполнить такое Java-приложение (это высокоуровневый язык програмирования... объектно-ориентированный) разработчик должен выполнить:
1. Загрузить класс (в форме байт-кода) в "JVM";
1(a). Здесь важно понимать что (в этом случае) наш "класс" - является одной законченно программой, которая содержит-укомплектована уже все требуемые для работы
      программные компоненты (методы)...
1(b). Компановщик классов для Java-приложения встроенный в "JVM" (он так настроен что уже автоматически может повторно использовать программный код - методы классов);
1(c). Класс Java-приложения уже хранится в низкоуровневом байт-коде, который сразу может выполняться в "JVM" (то есть, уже нет необходимости в создании низкоуровневого кода);
1(d). Все действия по запуску Java-приложения выполняются автоматически в среде "JVM"...;
А все остальные действия по разворачиванию-подготовке-запуску Java-приложения берет на себя "JVM". То есть, среда "JVM" очень сильно экономит время и ускоряет процесс
для выполнения Java-приложений...

                                                   Класс "Object" и его методы
                                                   ---------------------------
Класс "Object" - это прежде всего структура типа данных. При использовании данных, требуется обеспечить следующие условия:
- над данными можно выполнять логические и условные операции...
- обеспечить участие в многопоточных приложениях (взаимо-блокировку к общему рессурсу)...
- обеспечить участие в коллекциях (использование хеш-кода для работы с сортировками)...
- поскольку это базовый тип который может наследоваться в любую другую типа-структуру, возвращать текущий тип объекта...
- (и как заключающий элемент - при уничтожении объекта, обеспечить подготовку для корректного заверщения всех ранее запущенных операций...)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                               (Шаблон проектирования или паттерн) http://ru.wikipedia.org/wiki/Шаблон_проектирования#.D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5
          (32-шаблона, в том числе 23-шаблона используемых в Java)
(Применение шаблонов Java. Библиотека профессионала - Стелтинг С.) http://bulletinsite.net/index.php?id1=6&category=programmer&author=stelting-s&book=2002&page=96
                                (http://ooad.asf.ru/Patterns.aspx) http://ooad.asf.ru/Patterns.aspx
                       (Шпаргалка по 23-х шаблонов проектирования) http://habrahabr.ru/post/210288/

Виды паттернов:
1. Основные (fundamental):
   - ()........Delegation...................."Делегирование"
   - ()........Interface....................."Интерфейс"
   - ()........Abstract Superclass..........."Абстрактный суперкласс"
   - ()........Interface and Abstract Class.."Интерфейс и абстрактный класс"
   - ()........Immutable....................."Неизменный"
   - ()........Marker Interface.............."Маркер-интерфейс"
   - (~).......Ргоху........................."Заместитель"
2. Порождающие (creational - создают объекты):
   - (java 1)..Singleton....................."Одиночка"
   - (java 2)..FactoryMethod................."Фабричный метод"
   - (java 3)..AbstractFactory..............."Абстрактная фабрика"
   - (c++  4)..Builder......................."Строитель"
3. Распределения обязанностей:
   - (~).......Composite....................."Компоновщик"
4. Структурные (structural - они изменяют структуру уже готового созданого объекта):
   - (java 4)..Decorator....................."Декоратор"
   - (java 5)..Adapter......................."Адаптер"
   - (java 6)..Facade........................"Фасад"
   - (c++  2)..Proxy........................."Заместитель"
   - (c++  3)..Composite....................."Компоновщик"
   - ()........Iterator......................"Итератор"
   - ()........Bridge........................"Мост"
   - ()........Ayweight......................"Приспособленец"
   - ()........Dynamic Linkage..............."Динамическая компоновка"
   - ()........Virtual Proxy................."Виртуальный заместитель"
   - ()........Cache Management.............."Упрамение кэшем"
5. Поведенческие (behavioral):
   - (java 7)..Observer......................"Наблюдатель"
   - (java 8)..State........................."Состояние"
   - (java 9)..Strategy......................"Стратегия"
   - (c++  1)..Command......................."Команда"
   - ()........Chain of Responsibility......."llепочка ответственности"
   - ()........Mediator......................"Посредник"
   - ()........Null Object..................."Нулевой объект"
   - ()........Template Method..............."Метод шаблона"
   - ()........Visitor......................."Посетитель"
6. Для конкурирующих операций:
   - ()........Single Threaded Execution....."Однопоточное выполнение"
   - ()........Lock Object..................."Объект блокировки"
   - ()........Scheduler....................."Планировшик"
   - ()........Reducer Consumer.............."Производитель-потребитель"
7. Системные:
   - ()........Model-View-Controller (MVC)..."Модель-Вид-Контроллер"
   - ()........Session......................."Session Facade"
   - (~).......Worker Thread................."для улучшение пропускной способности и минимизация средней задержки при реализации параллельного выполнения"
   - ()........Callback......................"Обратный вызов"






*   (Паттерны ООП в метафорах) http://habrahabr.ru/post/136766/
*   (Шаблоны проектирования: основы велосипедостроения) http://www.slideshare.net/custisppt/ss-24614208
*   (Шаблоны проектирования. Строитель) http://icoder.ucoz.ru/blog/builder/2013-05-21-26
*   (Шпаргалка по шаблонам проектирования) http://habrahabr.ru/post/210288/

*** (Логические задачи.) http://sh2533.blogspot.com/

Шаблоны параллельного выполнения:
    (Описание паттерна) http://www.pvsm.ru/programmirovanie/17622
*   (Что такое MapReduce?) http://mrnone.blogspot.com/2011/12/mapreduce.html
                           http://swsys.ru/index.php?page=article&id=2247
*   (Параллельная реализация алгоритма обнаружения лиц) http://www.interactiverobotics.org/?p=98
                                                        http://www.interactiverobotics.org/?p=39
                                                        http://ru.wikipedia.org/wiki/MapReduce
                                                        http://akka.io/downloads/
                                                        http://www.myshared.ru/slide/687301/#
    (Параллельное выполнение в java. Шаблон Worker Thread) http://life-prog.ru/view_programs.php?id=49&language=java&page=1
    (Обзор java.util.concurrent) http://habrahabr.ru/company/luxoft/blog/157273/
    (Что такое Fork/Join? И с чем его едят?) http://www.1024cores.net/home/in-russian/cto-takoe-fork-join-i-s-cem-ego-edat
                                             https://toster.ru/q/23222


("Java_промышленное_программирование")
- Часть 1. ОСНОВЫ ЯЗЫКА JAVA
- Часть 2. ИСПОЛЬЗОВАНИЕ КЛАССОВ И БИБЛИОТЕК
- Часть 3. ТЕХНОЛОГИИ РАЗРАБОТКИ WEB-ПРИЛОЖЕНИЙ
- УКАЗАНИЯ И ОТВЕТЫ

"Шаблоны_проектирования_Java"
- r л а в а 4. Основные шаблоны проектирования
- r л а в а 5. Порождающие шаблоны проектирования
- r л а в а 6. Разделяющие шаблоны проектирования
- r л а в а 7. Структурные шаблоны проектирования
- r л а в а 8. Поведенческие шаблоны проектирования
- r л а в а 9. Шаблоны проектирования для конкурирующих операций

"Применение_шаблонов_Java" (Рассмотрено 32 шаблона, в том числе 23 шаблона, знание которых обязательно для сдачи экзамена на сертификат Sun Certified Enterprise Architect)
- ЧАСТЬ I . ОБЩЕУПОТРЕБИТЕЛЬНЫЕ ШАБЛОНЫ
-- Глава 1. Производящие шаблоны
-- Глава 2. Поведенческие шаблоны
-- Глава З. Структурные шаблоны
-- Глава 4. Системные шаблоны
- ЧАСТЬ П. ШАБЛОНЫ В ЯЗЫКЕ ПРОГРАММИРОВАНИЯ JAVA

("Обработка_вариаций_с_шаблонами_проектирования")

"Многопоточное_программирование_Java"
- Модели многопоточных вычислений:
-- Concurrency
-- MapReduce
-- Fork/Join - фреймворк для многопоточного программирования в Java 7 основанный на легковесных потоках (задачах).

"Проектирование_многопоточных_программ"
-- Процессы, обменивающиеся сообщениями


("Приёмы_параллельного_программирования_Java")
-- WorkManager API (JSR-237) - Средства параллельного программирования в J2EE

("Шаблон_параллельного_программирования_Т-подхода")
-- Модель Map-Reduce
-- стандарт MPI (Message Passing Interface)

("Введение_параллельные_вычисления")
-- Техгология MPI

(Основы_параллельных_вычислений)



Из оглавления (приведу только избранные разделы):
Глава 1. Дискретные системы
— Алгебра языков
— Конечные системы
— Многокомпонентные системы
— Автоматы
— Дискретные преобразователи
Глава 2 Алгоритмы
— Параллельные алгоритмы
Глава 3 Рекурсивные определения
Глава 4 Структуры данных
— Функциональные структуры данных
— Многоосновные структуры данных
Глава 5 Архитектура ЭВМ
— Не-неймовские ЭВМ
Глава 6 Проектирование последовательных программ
Глава 7 Распределенные многопроцессорные системы
— Принцип макроконвейра
— Макроконвейерные сети
— Проектирование распределенных программ
— Динамическое распараллеливание посл.программ


>Порождающие паттерны
>Системные паттерны
>Структурные паттерны
>Паттерны распределения обязанностей
Паттерны домена
Паттерны слоя источника данных
>Паттерны моделирования поведения
>Паттерны для представления данных в Web (Системные)


http://www.intuit.ru/studies/courses/16/16/lecture/498?page=2
http://www.duct-tape-architect.ru/?p=294
http://www.dil.univ-mrs.fr/~massat/docs/hibernate-2/reference/ru/html_single/
http://javadev.ru/
http://elizarov.livejournal.com/18000.html
http://life-prog.ru/view_programs.php?id=49&language=java&page=1
http://ooad.asf.ru/Pattern.aspx?IdKat=7&IdPat=60
http://mrnone.blogspot.com/2011/12/mapreduce.html


(java object методы)
        (Что такое класс Object? Какие в нем есть методы?) http://interviewinit.com/?p=270
(Ответы на вопросы для собеседования по Java SE (Часть 1)) http://dr-magic.blogspot.com/2009/01/java-se-1.html
                        (Java / Класс Object и его методы) http://www.quizful.net/interview/java/class-object-methods



